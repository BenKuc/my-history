A) project
    5) commands: set history on all existing rows
B) settings.py and docs
    3) history model naming scheme: when changing a new history-model is created
       and old one not tracked -> just choose initially? keep track in db of settings
       and create corresponding migrations automatically -> see Ideas for Future Features 1)
       -> better is a command for that
    5) utils.<custom bulk_create> just in docs or also for using as default?
C) Packaging
    1) provide package
    2) make name for app compatible -> see pip install options
D) apps.py
    1) configuration of name and verbose_name -> see C2
    2) import_models: create models there or in history
E) history.py
    1) implement methods
        1a) get_bases: how to handle multi-table-inheritance?
        1b) get_fields:
            - think of: reverse relations (also o2o and mt-inheritance o2o)
        1c) get_dict:
            - combine this with the below also using TRACKED_MODELS
            - exclude fields and fields + looping through the fields
        1d) get_meta_options:
            - set correct app_label
            - set correct db_table name
            - take a look at other stuff in django Meta docs
        1e) obj.history
            - .all() needs to be returned
            - obj.history is just a generic-reverse-descriptor
F) common/constants.py
    1) more information by model-cls and so on -> restructure code from __init__ again
    2) partially replace by django-checks?
G) common/validation.py
    1) make nicer composed error-messages
H) events/receivers.py
    1) implement them
I) events/models.py
    2) initial migration where checks are added (maybe django-constraints)
        - consistent content_type and same
        - create indexes in history_date and ...?
        - check constraints that prevent saving before/after when the type is create/update -> sql
L) utils/atomic_history.py
    1) create a decorator/context-manager that puts everything inside in one history event!
    2) corresponding to that: decorator + context manager: history.atomic ->
          all objects will be saved in the same history-event
    3) __init__:# which arguments does it need? initialize variables needed
    4) look into context-manager to see how to implement enter and exit
    5) implementation ideas:
        a) connect internal method (or dispatcher?) to all the signals
        b) this signal leads to not activating the other signals (maybe by disconnecting them temporarily)
        c) disconnect dispatcher and connect others again
M) utils/bulk_create.py
    1) bulk_create that can handle multi-table-inheritance
N) utils/no_history.py
    1) decorator/context-manager to skip history
    2) also no-history option for save, bulk,update by keyword-arg
O) General
    1) nice __str__ representation
P) testing


Ideas for future features
    1) ability to set tracking-connection -> continue to track a deleted model-
       instance by another model-instance. Rule for tracking can be a field-value
       or more generally a method that computes it. (or set explicitly)
    2) make full support for GenericForeignKeys with no int field as pk
        -> custom GenericForeignkey!
    3) Differences: make custom fields (or even generic): old and new value;
        option for has_changed; state_1 and state_2;
